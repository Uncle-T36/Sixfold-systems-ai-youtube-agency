/**
 * AUTOPILOT SERIES INTEGRATION
 * Automatically generates series content and schedules it without manual intervention
 * Set it once, let it run for months
 */

import { generateAdvancedVideo } from './advancedVideoGenerator';
import { generate30DaySchedule, AutopilotConfig, ScheduledPost } from './autopilotScheduler';

export interface AutoSeriesConfig {
  enabled: boolean;
  userId: string;
  channelId: string;
  
  // Series settings
  categories: StoryCategory[];
  scripterStyle: ScripterStyle;
  episodesPerWeek: number;
  seriesLength: number; // Episodes per series
  autoStartNewSeries: boolean; // Start new series when current ends
  
  // Video generation
  videoStyle: string; // From advancedVideoGenerator
  quality: 'standard' | 'high' | 'ultra';
  duration: 'short' | 'medium' | 'long'; // 5-8min, 10-15min, 20-30min
  
  // Scheduling
  postingDays: number[]; // 0-6 (Sunday-Saturday)
  postingTime: string; // "6:00 PM"
  timezone: string;
  
  // Content preferences
  viralScoreMinimum: number; // 70-100
  uniquenessMinimum: number; // 70-100
  targetAudience: string;
  avoidTopics: string[];
  
  // Autopilot behavior
  autoApprove: boolean; // Auto-approve generated content
  requireReview: boolean; // Hold for manual review
  backupEpisodes: number; // Keep N backup episodes ready
  notifications: {
    newEpisodeGenerated: boolean;
    seriesCompleted: boolean;
    lowQueue: boolean; // Alert when queue < 5 episodes
    viralPotential: boolean; // Alert when score > 95
  };
}

export type StoryCategory = 
  | 'unsolved-mysteries'
  | 'true-crime'
  | 'supernatural'
  | 'hidden-history'
  | 'survival-stories'
  | 'strange-science'
  | 'dark-psychology'
  | 'epic-adventures'
  | 'tech-mysteries'
  | 'money-power';

export type ScripterStyle = 
  | 'suspenseful-narrator'
  | 'dramatic-storyteller'
  | 'investigative-reporter'
  | 'cinematic-director'
  | 'conversational-friend'
  | 'educational-narrator';

export interface AutoGeneratedEpisode {
  id: string;
  seriesId: string;
  episodeNumber: number;
  title: string;
  description: string;
  script: string;
  category: StoryCategory;
  viralScore: number;
  uniquenessScore: number;
  estimatedViews: number;
  keywords: string[];
  thumbnailIdeas: string[];
  videoConfig: any; // AnimationConfig
  status: 'generating' | 'ready' | 'scheduled' | 'published' | 'failed';
  generatedAt: Date;
  scheduledFor?: Date;
  publishedAt?: Date;
}

export interface SeriesQueue {
  currentSeries: SeriesInfo | null;
  upcomingEpisodes: AutoGeneratedEpisode[];
  backupEpisodes: AutoGeneratedEpisode[];
  publishedCount: number;
  totalGenerated: number;
  queueHealth: 'excellent' | 'good' | 'warning' | 'critical';
  nextEpisodeDate: Date | null;
  daysUntilSeriesEnd: number;
}

export interface SeriesInfo {
  id: string;
  name: string;
  category: StoryCategory;
  totalEpisodes: number;
  publishedEpisodes: number;
  avgViralScore: number;
  avgViews: number;
  startedAt: Date;
  estimatedEndDate: Date;
}

// Story category configurations
const CATEGORY_CONFIGS: Record<StoryCategory, {
  viralPotential: number;
  avgViews: number;
  bestVideoStyle: string;
  recommendedDuration: string;
  postingFrequency: string;
}> = {
  'unsolved-mysteries': {
    viralPotential: 95,
    avgViews: 2500000,
    bestVideoStyle: '2d-cartoon-dark',
    recommendedDuration: 'medium',
    postingFrequency: '3x/week'
  },
  'true-crime': {
    viralPotential: 98,
    avgViews: 3200000,
    bestVideoStyle: 'anime-realistic',
    recommendedDuration: 'long',
    postingFrequency: '2x/week'
  },
  'supernatural': {
    viralPotential: 92,
    avgViews: 2800000,
    bestVideoStyle: '3d-cinematic',
    recommendedDuration: 'medium',
    postingFrequency: '3x/week'
  },
  'hidden-history': {
    viralPotential: 88,
    avgViews: 1900000,
    bestVideoStyle: 'documentary',
    recommendedDuration: 'long',
    postingFrequency: '2x/week'
  },
  'survival-stories': {
    viralPotential: 90,
    avgViews: 2300000,
    bestVideoStyle: 'motion-graphics',
    recommendedDuration: 'medium',
    postingFrequency: '3x/week'
  },
  'strange-science': {
    viralPotential: 85,
    avgViews: 1700000,
    bestVideoStyle: 'whiteboard-animated',
    recommendedDuration: 'short',
    postingFrequency: '4x/week'
  },
  'dark-psychology': {
    viralPotential: 93,
    avgViews: 2600000,
    bestVideoStyle: '2d-cartoon-dark',
    recommendedDuration: 'medium',
    postingFrequency: '3x/week'
  },
  'epic-adventures': {
    viralPotential: 87,
    avgViews: 2100000,
    bestVideoStyle: '3d-adventure',
    recommendedDuration: 'long',
    postingFrequency: '2x/week'
  },
  'tech-mysteries': {
    viralPotential: 89,
    avgViews: 2400000,
    bestVideoStyle: 'futuristic',
    recommendedDuration: 'medium',
    postingFrequency: '3x/week'
  },
  'money-power': {
    viralPotential: 91,
    avgViews: 2700000,
    bestVideoStyle: 'documentary',
    recommendedDuration: 'long',
    postingFrequency: '2x/week'
  }
};

/**
 * Initialize autopilot series system
 */
export function initializeAutoSeries(userId: string, channelId: string): AutoSeriesConfig {
  const defaultConfig: AutoSeriesConfig = {
    enabled: false,
    userId,
    channelId,
    categories: ['unsolved-mysteries', 'true-crime', 'supernatural'],
    scripterStyle: 'suspenseful-narrator',
    episodesPerWeek: 3,
    seriesLength: 10,
    autoStartNewSeries: true,
    videoStyle: '2d-cartoon-dark',
    quality: 'high',
    duration: 'medium',
    postingDays: [1, 3, 5], // Monday, Wednesday, Friday
    postingTime: '6:00 PM',
    timezone: 'America/New_York',
    viralScoreMinimum: 85,
    uniquenessMinimum: 80,
    targetAudience: 'Adults 18-45 interested in mysteries and storytelling',
    avoidTopics: [],
    autoApprove: true,
    requireReview: false,
    backupEpisodes: 5,
    notifications: {
      newEpisodeGenerated: true,
      seriesCompleted: true,
      lowQueue: true,
      viralPotential: true
    }
  };

  localStorage.setItem(`auto_series_config_${userId}`, JSON.stringify(defaultConfig));
  return defaultConfig;
}

/**
 * Start autopilot series generation
 * This is the main function that runs everything automatically
 */
export async function startAutopilotSeries(config: AutoSeriesConfig): Promise<SeriesQueue> {
  console.log('üöÄ Starting Autopilot Series Generator...');

  // Step 1: Check if we have an active series
  let currentSeries = await getCurrentSeries(config.userId);
  
  if (!currentSeries) {
    console.log('üìù No active series found. Creating new series...');
    currentSeries = await createNewSeries(config);
  }

  // Step 2: Check queue health
  const queue = await getSeriesQueue(config.userId);
  
  // Step 3: Generate episodes if queue is low
  if (queue.upcomingEpisodes.length < config.backupEpisodes) {
    const episodesToGenerate = config.backupEpisodes - queue.upcomingEpisodes.length;
    console.log(`üìπ Queue low. Generating ${episodesToGenerate} episodes...`);
    
    for (let i = 0; i < episodesToGenerate; i++) {
      const episode = await generateEpisode(config, currentSeries, queue.totalGenerated + i + 1);
      
      if (episode.viralScore >= config.viralScoreMinimum && 
          episode.uniquenessScore >= config.uniquenessMinimum) {
        queue.upcomingEpisodes.push(episode);
        console.log(`‚úÖ Episode ${episode.episodeNumber}: "${episode.title}" (Viral: ${episode.viralScore}%)`);
        
        // Notify if high viral potential
        if (episode.viralScore >= 95 && config.notifications.viralPotential) {
          await notifyHighViralPotential(config.userId, episode);
        }
      } else {
        console.log(`‚ùå Episode rejected (Viral: ${episode.viralScore}%, Unique: ${episode.uniquenessScore}%)`);
        i--; // Try again
      }
    }
  }

  // Step 4: Schedule episodes on posting days
  await scheduleEpisodes(config, queue);

  // Step 5: Check if series is complete and start new one
  if (currentSeries.publishedEpisodes >= config.seriesLength && config.autoStartNewSeries) {
    console.log('üé¨ Series complete! Starting new series...');
    await completeSeries(config.userId, currentSeries.id);
    await startAutopilotSeries(config); // Recursive - start new series
  }

  // Save queue state
  localStorage.setItem(`series_queue_${config.userId}`, JSON.stringify(queue));

  return queue;
}

/**
 * Generate a single episode with AI
 */
async function generateEpisode(
  config: AutoSeriesConfig,
  series: SeriesInfo,
  episodeNumber: number
): Promise<AutoGeneratedEpisode> {
  const category = config.categories[Math.floor(Math.random() * config.categories.length)];
  const categoryConfig = CATEGORY_CONFIGS[category];

  // Generate story prompt
  const storyPrompt = createStoryPrompt(category, config.scripterStyle, episodeNumber);
  
  // In production, this would call Claude/Copilot
  // For now, we'll use templates
  const story = await generateStoryContent(storyPrompt, config.scripterStyle);

  // Calculate viral and uniqueness scores
  const viralScore = calculateViralScore(story, category);
  const uniquenessScore = calculateUniquenessScore(story);

  // Generate video configuration
  const videoConfig = await generateAdvancedVideo(
    {
      title: story.title,
      script: story.script,
      niche: category,
      duration: getDurationMinutes(config.duration)
    },
    categoryConfig.bestVideoStyle
  );

  const episode: AutoGeneratedEpisode = {
    id: `episode_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    seriesId: series.id,
    episodeNumber,
    title: story.title,
    description: story.description,
    script: story.script,
    category,
    viralScore,
    uniquenessScore,
    estimatedViews: Math.round(categoryConfig.avgViews * (viralScore / 100)),
    keywords: story.keywords,
    thumbnailIdeas: story.thumbnailIdeas,
    videoConfig,
    status: 'ready',
    generatedAt: new Date()
  };

  return episode;
}

/**
 * Create story prompt for AI generation
 */
function createStoryPrompt(category: StoryCategory, style: ScripterStyle, episodeNumber: number): string {
  const categoryPrompts: Record<StoryCategory, string> = {
    'unsolved-mysteries': `Create a chilling unsolved mystery story that has never been widely covered. Focus on strange disappearances, unexplained phenomena, or cold cases. Make it suspenseful and leave viewers wanting more.`,
    'true-crime': `Generate a compelling true crime story with shocking twists. Focus on lesser-known cases, criminal psychology, and forensic details. Build tension throughout.`,
    'supernatural': `Create a paranormal story with credible witnesses and unexplained events. Could be hauntings, UFOs, cryptids, or supernatural phenomena. Make it eerie and mysterious.`,
    'hidden-history': `Uncover a fascinating historical event or figure that's been forgotten or suppressed. Focus on surprising facts and hidden connections. Make history exciting.`,
    'survival-stories': `Tell an incredible survival story against all odds. Could be wilderness survival, disaster escape, or life-threatening situations. Emphasize the human spirit.`,
    'strange-science': `Explore weird scientific phenomena, bizarre experiments, or mind-blowing discoveries. Make complex topics accessible and fascinating.`,
    'dark-psychology': `Dive into dark psychology, manipulation tactics, or the criminal mind. Explain psychological concepts through real examples. Both educational and captivating.`,
    'epic-adventures': `Tell an epic adventure story of exploration, treasure hunting, or dangerous quests. Focus on courage, discovery, and overcoming obstacles.`,
    'tech-mysteries': `Explore unsolved tech mysteries, cyber crimes, dark web secrets, or technological enigmas. Make tech topics thrilling and accessible.`,
    'money-power': `Reveal stories of wealth, corruption, power plays, or financial scandals. Focus on how money and power shape our world. Shocking and eye-opening.`
  };

  const styleInstructions: Record<ScripterStyle, string> = {
    'suspenseful-narrator': 'Write in a dark, mysterious tone. Use dramatic pauses, build tension, create atmosphere. Like a thriller novel.',
    'dramatic-storyteller': 'Write with emotional intensity. Use vivid descriptions, dramatic reveals, compelling narrative. Like a blockbuster movie.',
    'investigative-reporter': 'Write factually but compellingly. Present evidence, interview quotes, chronological events. Like a documentary.',
    'cinematic-director': 'Write visually and immersively. Describe scenes cinematically, use sensory details. Like a film script.',
    'conversational-friend': 'Write casually but engagingly. Tell the story like chatting with a friend. Relatable and accessible.',
    'educational-narrator': 'Write clearly and informatively. Explain concepts, provide context, teach while entertaining. Like an engaging lecture.'
  };

  return `${categoryPrompts[category]}

STYLE: ${styleInstructions[style]}

EPISODE NUMBER: ${episodeNumber} (Ensure this fits into a larger series with callback potential)

REQUIREMENTS:
- Duration: 10-15 minutes of content
- Hook: Incredible opening that grabs attention in first 10 seconds
- Structure: Clear beginning, middle, end with rising tension
- Cliffhanger: End with something that makes viewers want the next episode
- Viral elements: Shocking facts, "wait what??" moments, shareability
- SEO keywords: Include searchable terms naturally
- Call-to-action: Natural prompt to subscribe/watch next episode

GENERATE:
1. Title (viral, curiosity-driven, under 70 characters)
2. Hook (first 30 seconds - must be INCREDIBLE)
3. Full script (10-15 minutes)
4. Description (SEO-optimized, 150-200 words)
5. Keywords (10 searchable terms)
6. Thumbnail ideas (3 visual concepts)
7. Next episode tease (cliffhanger preview)

Make it UNIQUE - check that this story hasn't been covered extensively on YouTube.`;
}

/**
 * Generate story content (would use Claude/Copilot in production)
 */
async function generateStoryContent(prompt: string, style: ScripterStyle): Promise<any> {
  // In production: Call Claude or use Copilot
  // For now, return template
  
  return {
    title: `The Vanishing Village: 1,200 People Disappeared Without a Trace`,
    hook: `In 1930, an entire Inuit village of 1,200 people vanished overnight. Their food was still warm. Their belongings untouched. But every single person... gone. What happened in that frozen wasteland?`,
    script: `[Full 10-15 minute script would be here with detailed storytelling, facts, theories, and dramatic narration]`,
    description: `The Anjikuni village mystery is one of the most disturbing mass disappearances in history. In 1930, Canadian fur trapper Joe Labelle discovered an entire Inuit village completely abandoned - with fires still burning and food still warm on tables. But all 1,200 inhabitants had vanished without a trace. No bodies were ever found. No evidence of struggle. Just... empty. This video explores the theories, the evidence, and the chilling truth about what may have happened in the frozen Canadian wilderness. Subscribe for more unsolved mysteries!`,
    keywords: ['unsolved mystery', 'mass disappearance', 'Anjikuni village', 'vanished without trace', 'true mystery', 'unexplained disappearance', 'creepy stories', 'mystery stories', 'unsolved cases', 'disturbing mysteries'],
    thumbnailIdeas: [
      'Empty village with ghostly atmosphere, person silhouette asking "Where did they go?"',
      'Split screen: warm food on table / empty snowy village',
      'Shocked face with text: "1,200 PEOPLE VANISHED"'
    ],
    nextEpisodeTease: `But this wasn't the only mass vanishing. In our next episode, we'll explore the Roanoke colony - where an entire settlement disappeared, leaving only one word carved into a tree...`
  };
}

/**
 * Calculate viral score based on content
 */
function calculateViralScore(story: any, category: StoryCategory): number {
  let score = CATEGORY_CONFIGS[category].viralPotential;
  
  // Boost for elements
  if (story.title.length < 70) score += 2;
  if (story.hook.includes('?')) score += 3;
  if (story.keywords.length >= 10) score += 2;
  if (story.thumbnailIdeas.length >= 3) score += 1;
  
  return Math.min(100, score);
}

/**
 * Calculate uniqueness score
 */
function calculateUniquenessScore(story: any): number {
  // In production: Check against existing content database
  return Math.floor(Math.random() * 20) + 80; // 80-100
}

/**
 * Schedule episodes on configured days
 */
async function scheduleEpisodes(config: AutoSeriesConfig, queue: SeriesQueue): Promise<void> {
  const now = new Date();
  const unscheduledEpisodes = queue.upcomingEpisodes.filter(e => !e.scheduledFor);

  let scheduledCount = 0;
  let currentDate = new Date(now);

  for (const episode of unscheduledEpisodes) {
    // Find next posting day
    while (!config.postingDays.includes(currentDate.getDay())) {
      currentDate.setDate(currentDate.getDate() + 1);
    }

    // Set posting time
    const [hours, minutes] = parseTime(config.postingTime);
    currentDate.setHours(hours, minutes, 0, 0);

    // Schedule episode
    episode.scheduledFor = new Date(currentDate);
    episode.status = 'scheduled';

    console.log(`üìÖ Scheduled "${episode.title}" for ${currentDate.toLocaleString()}`);

    // Move to next posting day
    currentDate.setDate(currentDate.getDate() + 1);
    scheduledCount++;

    // Don't schedule more than needed
    if (scheduledCount >= config.episodesPerWeek * 2) break;
  }

  queue.nextEpisodeDate = queue.upcomingEpisodes
    .filter(e => e.scheduledFor)
    .sort((a, b) => a.scheduledFor!.getTime() - b.scheduledFor!.getTime())[0]?.scheduledFor || null;
}

/**
 * Get current active series
 */
async function getCurrentSeries(userId: string): Promise<SeriesInfo | null> {
  const stored = localStorage.getItem(`current_series_${userId}`);
  return stored ? JSON.parse(stored) : null;
}

/**
 * Create new series
 */
async function createNewSeries(config: AutoSeriesConfig): Promise<SeriesInfo> {
  const category = config.categories[0]; // Use primary category
  
  const series: SeriesInfo = {
    id: `series_${Date.now()}`,
    name: `${category} Series ${new Date().getFullYear()}`,
    category,
    totalEpisodes: config.seriesLength,
    publishedEpisodes: 0,
    avgViralScore: 0,
    avgViews: 0,
    startedAt: new Date(),
    estimatedEndDate: calculateSeriesEndDate(config)
  };

  localStorage.setItem(`current_series_${config.userId}`, JSON.stringify(series));
  return series;
}

/**
 * Get series queue
 */
async function getSeriesQueue(userId: string): Promise<SeriesQueue> {
  const stored = localStorage.getItem(`series_queue_${userId}`);
  if (stored) return JSON.parse(stored);

  return {
    currentSeries: null,
    upcomingEpisodes: [],
    backupEpisodes: [],
    publishedCount: 0,
    totalGenerated: 0,
    queueHealth: 'critical',
    nextEpisodeDate: null,
    daysUntilSeriesEnd: 0
  };
}

/**
 * Complete current series and archive
 */
async function completeSeries(userId: string, seriesId: string): Promise<void> {
  const series = await getCurrentSeries(userId);
  if (series) {
    // Archive series
    const archived = JSON.parse(localStorage.getItem(`archived_series_${userId}`) || '[]');
    archived.push({ ...series, completedAt: new Date() });
    localStorage.setItem(`archived_series_${userId}`, JSON.stringify(archived));
    
    // Clear current
    localStorage.removeItem(`current_series_${userId}`);
  }
}

/**
 * Notify user of high viral potential
 */
async function notifyHighViralPotential(userId: string, episode: AutoGeneratedEpisode): Promise<void> {
  console.log(`üî• HIGH VIRAL POTENTIAL: "${episode.title}" - ${episode.viralScore}% | Est. ${episode.estimatedViews.toLocaleString()} views`);
  // In production: Send email/SMS notification
}

// Helper functions
function getDurationMinutes(duration: string): number {
  const durations = { short: 7, medium: 12, long: 25 };
  return durations[duration as keyof typeof durations] || 12;
}

function parseTime(timeStr: string): [number, number] {
  const [time, period] = timeStr.split(' ');
  let [hours, minutes] = time.split(':').map(Number);
  if (period === 'PM' && hours !== 12) hours += 12;
  if (period === 'AM' && hours === 12) hours = 0;
  return [hours, minutes];
}

function calculateSeriesEndDate(config: AutoSeriesConfig): Date {
  const weeksNeeded = Math.ceil(config.seriesLength / config.episodesPerWeek);
  const endDate = new Date();
  endDate.setDate(endDate.getDate() + (weeksNeeded * 7));
  return endDate;
}

/**
 * Get autopilot status dashboard
 */
export function getAutopilotStatus(userId: string): {
  isActive: boolean;
  currentSeries: SeriesInfo | null;
  queue: SeriesQueue;
  stats: {
    episodesThisWeek: number;
    episodesThisMonth: number;
    avgViralScore: number;
    totalEstimatedViews: number;
    daysUntilQueueEmpty: number;
  };
} {
  const config = JSON.parse(localStorage.getItem(`auto_series_config_${userId}`) || 'null');
  const series = JSON.parse(localStorage.getItem(`current_series_${userId}`) || 'null');
  const queue = JSON.parse(localStorage.getItem(`series_queue_${userId}`) || '{"upcomingEpisodes":[]}');

  return {
    isActive: config?.enabled || false,
    currentSeries: series,
    queue,
    stats: {
      episodesThisWeek: queue.upcomingEpisodes.filter((e: AutoGeneratedEpisode) => {
        if (!e.scheduledFor) return false;
        const weekAgo = new Date();
        weekAgo.setDate(weekAgo.getDate() - 7);
        return new Date(e.scheduledFor) > weekAgo;
      }).length,
      episodesThisMonth: queue.upcomingEpisodes.length,
      avgViralScore: queue.upcomingEpisodes.reduce((sum: number, e: AutoGeneratedEpisode) => sum + e.viralScore, 0) / queue.upcomingEpisodes.length || 0,
      totalEstimatedViews: queue.upcomingEpisodes.reduce((sum: number, e: AutoGeneratedEpisode) => sum + e.estimatedViews, 0),
      daysUntilQueueEmpty: queue.upcomingEpisodes.length > 0 ? Math.ceil((queue.upcomingEpisodes.length / config.episodesPerWeek) * 7) : 0
    }
  };
}
